package jhg.appman;


import java.util.List;
import java.util.Map;

import jhg.Action;
import jhg.State;
import jhg.User;
import jhg.model.Field;
import jhg.model.Manager;
import jhg.model.Model;
import jhg.model.Value;




/**
 * The dependency between the adaptor and jmodel.
 * The dependency between the database, jdbc is in Database.
 * @author John
 *
 */
@SuppressWarnings({"rawtypes"})
public class SqlTranslator {

	public static final String AUTO_PK = "id INTEGER GENERATED BY DEFAULT AS IDENTITY (START WITH 1, INCREMENT BY 1) PRIMARY KEY ";
	public static final String PLAIN_PK = "id INTEGER NOT NULL PRIMARY KEY ";
	public static final String CURRENT_TIMESTAMP = "CURRENT_TIMESTAMP";
	

	
	/**
	 * Default dialect is hsql.
	 * 
	 * @param __manager
	 * @return
	 */
	@SuppressWarnings("unchecked")
	public static String createTable(Manager _manager) {
		StringBuilder sb = new StringBuilder();
		sb.append("CREATE TABLE "+_manager.getName().toUpperCase()+"("+AUTO_PK+", ");
		sb.append("VERSION_ID INTEGER, ");
		sb.append("OWNER_ID INTEGER, ");
		sb.append("APPROVER_ID INTEGER, ");
		sb.append("STATE INTEGER, ");
		//sb.append("OPEN_BY_ID INTEGER, ");                       Locks will be cached only. this is only if doing persisted cache
		//sb.append("OPEN_DATE TIMESTAMP, ");//starts the lock.
		
		//sb.append("HITS_LAST_MONTH INTEGER, ");
		//sb.append("HITS_THIS_MONTH INTEGER, ");//used to compute a cache score if needed
		
		List<Field> __fields = _manager.getFields();
		int i = 0;
		int listsize = __fields.size();
		for(Field __field:__fields){
			//id,key,fk,plain
			sb.append(__field.toDDL());
			i++;
			if(i<listsize){
				sb.append(",");
			}
		}
		sb.append(")");
		return sb.toString();
	}
	
	private static void log(String string) {
		System.out.println(string);
	}

	private static String translateType(int _type){
		switch (_type){
			case java.sql.Types.BOOLEAN: return "BOOLEAN";	
			case java.sql.Types.BIGINT: return "BIGINT";
			case java.sql.Types.INTEGER: return "INTEGER";
			case java.sql.Types.SMALLINT: return "SMALLINT";
			case java.sql.Types.TINYINT: return "TINYINT";
			case java.sql.Types.DOUBLE: return "DOUBLE";
			case java.sql.Types.DECIMAL: return "DECIMAL";
			case java.sql.Types.TIMESTAMP: return "TIMESTAMP";
			case java.sql.Types.DATE: return "DATE";
			case java.sql.Types.TIME: return "TIME";
			case java.sql.Types.CHAR: return "CHAR";
			case java.sql.Types.VARCHAR: return "VARCHAR";
			default: throw new IllegalArgumentException("PE: The passed in type "+_type+" cannot be translated.");
		}
	}

	public static String dropTable(String __tablename) {
		StringBuilder sb = new StringBuilder();
		sb.append("DROP TABLE "+__tablename);
		return sb.toString();
	}


	
	public static String createDeleteAll(Manager __manager){
		StringBuilder sb = new StringBuilder();
		sb.append("DELETE FROM ");
		sb.append(__manager.getName());
		return sb.toString();				
	}

	public static String createCountQuery(Manager m){
		StringBuilder sb = new StringBuilder();
		sb.append("SELECT COUNT(*) FROM "+m.getName());
		return sb.toString();
	}

	public static String createSelect(Manager m, int id){
		log("createSelect:"+m.getName()+":"+id);
		StringBuilder sb = new StringBuilder();
		sb.append("SELECT * FROM ");
		sb.append(m.getName());
		sb.append(" WHERE ID "+" = "+id);//replaced m.getId().getName() with ID
		return sb.toString();				
	}	
	
	public static String createDelete(Model model){
		//log(model.debug());
		log(model.toString());
		StringBuilder sb = new StringBuilder();
		sb.append("DELETE FROM ");
		sb.append(model.getManager().getName());
		sb.append(" WHERE ID = "+model.getId().toString());//replaced model.getManager().getId().getName() with ID
		return sb.toString();				
	}
	

	/*
	public static String createUpdate(Model model){
		//log(model.debug());
		//log(model.toString());
		StringBuilder sb = new StringBuilder();
		sb.append("UPDATE ");
		sb.append(model.getManager().getName());
		sb.append(" SET ");
		Map<Field,Value> fieldValues = model.getFieldValues();
		int i = 0;
		for(Field __field:fieldValues.keySet()){
			if(!__field.isIdentity()){
				sb.append(__field.getName());
				sb.append(" = ");
				translateType(__field.getSqlType());//SupportedTypes _t = SupportedTypes.getType(__field.getType());
				Value _v = fieldValues.get(__field);
				//String value = _v.toString();
				/*
				if(SupportedTypes.TIME.equals(_t)||SupportedTypes.TIMESTAMP.equals(_t)){
					value = fixTimeZone(value);
				}
				value = ((_t.isQuoted())?("'"+value+"'"):value);
				* /
				sb.append(_v.toSql());
				if(i<fieldValues.size()-1){
					sb.append(" ,  ");
				}
			}
			i++;
		}
		sb.append(" WHERE ID = "+model.getId().toString());//"+model.getManager().getId().getName()+" replaced with ID
		return sb.toString();		
	}
	*/
	
	public static String createInsert(Model model) {
		//log(model.debug());
		log(model.toString());
		//Integer ownerId = owner.getId();

		StringBuilder sb = new StringBuilder();
		sb.append("INSERT INTO ");
		sb.append(model.getManager().getName());
		sb.append(" (");
		sb.append(" OWNER_ID, STATE, VERSION_ID, ");//NOTE, we try to put the state in storage in advance but it will rollback, memory is not updated until successful.
		Map<Field,Value> fieldValues = model.getEnteredFieldValues();
		int i = 0;
		for(Field __field:fieldValues.keySet()){
			if(!__field.isIdentity()){
				sb.append(__field.getName());
				//System.out.println("fieldValues.size():"+fieldValues.size());
				if(i<fieldValues.size()-1 ){
					sb.append(",");
				}
			}
			i++;
		}
		sb.append(" ) VALUES ( ");
		
		sb.append(model.getOwnerId()+", "+(model.getState().ordinal())+", "+model.getVersionId()+", ");
		int j = 0;
		for(Field __field:fieldValues.keySet()){
			if(!__field.isIdentity()){
				Value _v = fieldValues.get(__field);

				sb.append(_v.toSql());
				if(j<fieldValues.size()-1 && fieldValues.size()>1){
					sb.append(",");
				}
			}
			j++;
		}		
		sb.append(" ) ");
		return sb.toString();
	}

	public static String createUpdate(Model model) {
		log(model.toString());
		//Integer writerId = writer.getId();
		StringBuilder sb = new StringBuilder();
		sb.append("UPDATE ");
		sb.append(model.getManager().getName());
		sb.append(" SET VERSION_ID = "+model.getVersionId()+", ");
		Map<Field,Value> fieldValues = model.getEnteredFieldValues();
		int i = 0;
		for(Field __field:fieldValues.keySet()){
			if(!__field.isIdentity()){
				sb.append(__field.getName());
				sb.append(" = ");
				//translateType(__field.getSqlType());//SupportedTypes _t = SupportedTypes.getType(__field.getType());
				Value _v = fieldValues.get(__field);
				sb.append(_v.toSql());
				if(i<fieldValues.size()-1){
					sb.append(" ,  ");
				}
			}
			i++;
		}
		sb.append(" WHERE ID = "+model.getId().toString());//"+model.getManager().getId().getName()+" replaced with ID
		return sb.toString();		
	}	
	
	public static String callIdentity() {
		return "CALL IDENTITY();";
	}

	public static String createSelectAll(Manager __manager) {
		StringBuilder sb = new StringBuilder();
		sb.append("SELECT * FROM "+__manager.getName());
		return sb.toString();
	}

	public static String createSelectCount(Manager __manager) {
		StringBuilder sb = new StringBuilder();
		sb.append("SELECT COUNT(*) FROM "+__manager.getName());
		return sb.toString();
	}
	
	public static String createSelectModelHistory(Model m){
		StringBuilder sb = new StringBuilder();
		Manager manager = m.getManager();
		sb.append("SELECT CHANGE_ID, EVENT_ID, EVENT_STAMP, ");//5
		sb.append(" USER_ID, ROLE_ID, CLIENT, COMMENTS, TXFR_USER_ID ");//5
		sb.append(" FROM "+Model.AUX_MODEL+" ");
		sb.append(" WHERE MANAGER_ID="+manager.getManagerId()+" ");
		sb.append(" AND MODEL_ID = "+m.getId()+"   ");
		return sb.toString();
	}

	public static String createModelHistoryInsert(Action action) {
		StringBuilder sb = new StringBuilder();
		
		sb.append("INSERT INTO ");
		sb.append(Model.AUX_MODEL+"( MANAGER_ID, MODEL_ID, CHANGE_ID, EVENT_ID, EVENT_STAMP, ");
		sb.append(" USER_ID, ROLE_ID, CLIENT, COMMENTS, TXFR_USER_ID, SIGNATURE  ) VALUES ( ");//NOTE: took out changes
		sb.append(action.getManagerId()+", ");		//MANAGER_ID
		sb.append(action.getModelId()+", ");   		//MODEL_ID
		sb.append(action.getChangeId()+", ");		//CHANGE_ID
		sb.append(action.getCode().ordinal()+", ");	//EVENT_ID     Usually Event.CREATE or Event.IMPORT
		sb.append(CURRENT_TIMESTAMP+", ");			//EVENT_STAMP
		sb.append(action.getUserId()+", ");			//USER_ID
		sb.append(action.getRoleId()+", ");			//ROLE_ID
		sb.append("'"+action.getClient()+"', ");	//CLIENT
		//sb.append("'"+action.getChanges()+"', ");	//CHANGES   
		sb.append("'"+action.getComment()+"', ");	//COMMENTS
		sb.append(action.getTxfrUserId()+", ");     //TXFR_USER_ID
		sb.append("'"+action.getSignature()+"' "); //SIGNATURE
		sb.append(")");
		return sb.toString();
	}

	public static String createStateVersionUpdate(Model model) {
		log(model.toString());
		//Integer writerId = writer.getId();
		StringBuilder sb = new StringBuilder();
		sb.append("UPDATE ");
		sb.append(model.getManager().getName());
		sb.append(" SET VERSION_ID = "+model.getVersionId()+", ");
		sb.append(" STATE = "+model.getState().ordinal()+" ");
		sb.append(" WHERE ID = "+model.getId().toString());
		return sb.toString();	
	}
	
	public static String createOwnerUpdate(Model model) {
		log(model.toString());
		//Integer writerId = writer.getId();
		StringBuilder sb = new StringBuilder();
		sb.append("UPDATE ");
		sb.append(model.getManager().getName());
		sb.append(" SET OWNER_ID = "+model.getOwnerId()+" ");
		sb.append(" WHERE ID = "+model.getId().toString());
		return sb.toString();	
	}
	public static String createApproverUpdate(Model model) {
		log(model.toString());
		//Integer writerId = writer.getId();
		StringBuilder sb = new StringBuilder();
		sb.append("UPDATE ");
		sb.append(model.getManager().getName());
		sb.append(" SET OWNER_ID = "+model.getApproverId()+" ");
		sb.append(" WHERE ID = "+model.getId().toString());
		return sb.toString();	
	}


}

/*
public static String createSelectAllRowsKeyColumns(@SuppressWarnings("rawtypes") Manager __manager) {
	StringBuilder sb = new StringBuilder();
	sb.append("SELECT ");
	sb.append(__manager.getId().getName()+", ");
	int i=0;
	if(__manager.isMultiKey()){
		@SuppressWarnings("unchecked")
		LinkedHashSet<ForeignIdField> fkFields = __manager.getMultiKey();
		for(ForeignIdField fkField:fkFields){
			sb.append(fkField.getName()+", ");
			if(i<__manager.getMultiKey().size()-1){
				sb.append(",");
			}				
		    i++;	
		}
	}else{
		sb.append(__manager.getKey().getName());
	}
	Set<IField> fields = __manager.getFilterIndexes().keySet();
	int j = 0;
	for(IField field:fields){
		sb.append(field.getName()+", ");
		if(j<fields.size()-1){
			sb.append(",");
		}				
	    j++;	
	}
	
	sb.append(" FROM "+__manager.getName());
	return sb.toString();
}
*/

/*
public static String createSchema(String schema) {
	StringBuilder sb = new StringBuilder();
	sb.append("CREATE SCHEMA "+ schema+" AUTHORIZATION DBA");
	return sb.toString();
}
*/
/*

 * 
CREATE TABLE

CREATE [MEMORY | CACHED | [GLOBAL] TEMPORARY | TEMP [2] | TEXT[2]] TABLE <name>
    ( <columnDefinition> [, ...] [, <constraintDefinition>...] )
    [ON COMMIT {DELETE | PRESERVE} ROWS];
Creates a tables in memory (default) or on disk and only cached in memory. If 
the database is all-in-memory, both MEMORY and CACHED forms of CREATE TABLE 
return a MEMORY table while the TEXT form is not allowed.

Components of a CREATE TABLE command





columnDefinition
columnname Datatype [(columnSize[,precision])]
    [{DEFAULT <defaultValue> |
    GENERATED BY DEFAULT AS IDENTITY
    (START WITH <n>[, INCREMENT BY <m>])}] |
    [[NOT] NULL] [IDENTITY] [PRIMARY KEY]
Default values that are allowed are constant values or certain SQL 
datetime functions.

Allowed Default Values in Column Definitions

For character column, a single-quoted string or NULL. The only SQL function 
that can be used is CURRENT_USER.

For datetime columns, a single-quoted DATE, TIME or TIMESTAMP value or NULL. 
Or a datetime SQL function such as CURRENT_DATE, CURRENT_TIME, 
CURRENT_TIMESTAMP, TODAY, NOW. Each function is allowed for a certain 
datetime type.

For BOOLEAN columns, the literals FALSE, TRUE, NULL.

For numeric columns, any valid number or NULL.

For binary columns, any valid hex string or NULL.

Only one identity column is allowed in each table. Identity columns are 
autoincrement columns. They must be of INTEGER or BIGINT type and are 
automatically primary key columns (as a result, multi-column primary 
keys are not possible with an IDENTITY column present). Using the 
long SQL syntax the (START WITH <n>) clause specifies the first 
value that will be used. The last inserted value into an identity 
column for a connection is available using the function IDENTITY(), 
for example (where Id is the identity column):

INSERT INTO Test (Id, Name) VALUES (NULL,'Test');
    CALL IDENTITY();
    
    
    
    
constraintDefinition
[CONSTRAINT <name>]
    UNIQUE ( <column> [,<column>...] ) |
    PRIMARY KEY ( <column> [,<column>...] ) |
    FOREIGN KEY ( <column> [,<column>...] )
    REFERENCES <refTable> ( <column> [,<column>...]) 
    [ON {DELETE | UPDATE}
    {CASCADE | SET DEFAULT | SET NULL}][2] |
    CHECK(<search condition>)[2]
Both ON DELETE and ON UPDATE clauses can be used in a single 
foreign key definition.

search condition
A search condition is similar to the set of conditions in a WHERE 
clause. In the current version of HSQLDB, the conditions for a 
CHECK constraint can only reference the current row, meaning there 
should be no SELECT statement. Sample table definitions with CHECK 
constraints are in TestSelfCheckConstraints.txt. This file is in 
the /hsqldb/testrun/hsqldb/ directory of the zip.

General syntax limitations
HSQLDB databases are initially created in a legacy mode that does 
not enforce column size and precision. You can set the 
property: sql.enforce_strict_size=true to enable this feature. 
When this property has been set, Any supplied column size and 
precision for numeric and character types (CHARACTER and VARCHAR) 
are enforced. Use the command, SET PROPERTY 
"sql.enforce_strict_size" TRUE once before defining the tables.

NOT NULL constraints can be part of the column definition only. 
Other constraints cannot be part of the column definition and must 
appear at the end of the column definition list.

TEMPORARY TABLE contents for each session (connection) are emptied 
by default at each commit or rollback. The optional 
qualifier ON COMMIT PRESERVE ROWS can be used to keep the rows 
while the session is open. The default is ON COMMIT DELETE ROWS.







---------------------------

1. INTEGER | INT	as Java type	int | java.lang.Integer

2. DOUBLE [PRECISION] | FLOAT	as Java type	double | java.lang.Double
	REAL	as Java type	double | java.lang.Double[2]

3. VARCHAR	as Integer.MAXVALUE	java.lang.String
	VARCHAR_IGNORECASE	as Integer.MAXVALUE	java.lang.String
	CHAR | CHARACTER	as Integer.MAXVALUE	java.lang.String
	LONGVARCHAR	as Integer.MAXVALUE	java.lang.String

4. DATE	as Java type	java.sql.Date
5. TIME	as Java type	java.sql.Time
6. TIMESTAMP | DATETIME	as Java type	java.sql.Timestamp

7. DECIMAL	No limit	java.math.BigDecimal
	NUMERIC	No limit	java.math.BigDecimal

8. BOOLEAN | BIT	as Java type	boolean | java.lang.Boolean

9. TINYINT	as Java type	byte | java.lang.Byte

10. SMALLINT	as Java type	short | java.lang.Short

11. BIGINT	as Java type	long | java.lang.Long


12. BINARY	as Integer.MAXVALUE	byte[]
	VARBINARY	as Integer.MAXVALUE	byte[]
	LONGVARBINARY	as Integer.MAXVALUE	byte[]

13. OTHER | OBJECT	as Integer.MAXVALUE	java.lang.Object
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
static int	ARRAY 
static int	BLOB
static int	CLOB 
static int	DATALINK 
static int	DISTINCT 
static int	NULL 
static int	REF 
static int	STRUCT 

static int	BIGINT #
static int	BINARY #
static int	BIT #
static int	BOOLEAN #
static int	CHAR #
static int	DATE #
static int	DECIMAL #
static int	DOUBLE #
static int	FLOAT #
static int	INTEGER #
static int	JAVA_OBJECT # (OBJECT)
static int	LONGVARBINARY #
static int	LONGVARCHAR #
static int	NUMERIC #
static int	OTHER #
static int	REAL #
static int	SMALLINT #
static int	TIME #
static int	TIMESTAMP #
static int	TINYINT #
static int	VARBINARY #
static int	VARCHAR #
 * 

*/
/*
* Adaptor that understands the jmodel and converts to empire-db.
* http://empire-db.apache.org/javadocs/empire-db/index.html?org/apache/empire/db/DBTable.html
* http://empire-db.apache.org/documentation/documentation.htm


commons-logging-1.0.4.jar
commons-collections-2.1.1.jar
commons-beanutils-1.7.0.jar
empire-db-2.0.0.jar
log4j-1.2.14.jar
hsqldb.jar
*/

/*
* 
* @param _manager
* @return

static DBTable convert(Manager _manager){
DBTable 
}*/

/*
 * createTable 
 *
sb.append(__field.getName()+" ");
String __type = translateType(__field.getSqlType());
sb.append(__type);

boolean supportingSize = __type.supportsSize()&& __field.getLength()!=-1;
boolean supportingScale = __type.supportsScale()&& __field.getScale()!=-1;
boolean supportingPrec = __type.supportsPrec()&& __field.getPrecision()!=-1;

if(supportingSize && !supportingScale && !supportingPrec){//CHAR,VARCHAR
	sb.append("(");
	sb.append(__field.getLength());
	sb.append(")");
}else if (supportingPrec && !supportingSize && !supportingScale){//TIME,TIMESTAMP
	sb.append("(");
	sb.append(__field.getPrecision());
	sb.append(")");
}else if(!supportingSize && supportingScale && supportingPrec){//DECIMAL
	////the scale must be smaller than the precision by at least 1. So (100,100) does not work, (100,99) does.
	sb.append("(");
	sb.append(__field.getPrecision());
	sb.append(",");
	sb.append(__field.getScale());
	sb.append(")");
}
if(SupportedTypes.TIME.equals(__type) || SupportedTypes.TIMESTAMP.equals(__type)){
	sb.append(" WITH TIME ZONE");
}			
//Currently not supported is the default value, we opt to take care of it here.

sb.append(" ");
if(!__field.isIdentity() ){
	if(!__field.isNullable()){ 
		sb.append("NOT");
		sb.append(" ");
	}
	sb.append("NULL");
	sb.append(" ");
}

if(__field.isIdentity()){
	sb.append("GENERATED BY DEFAULT AS IDENTITY (START WITH 1, INCREMENT BY 1)");//"GENERATED ALWAYS AS IDENTITY");
	sb.append(" ");
}

if(__field.isPrimary()){
	sb.append("PRIMARY KEY");
}
//log("i:"+i);
//log("__fields.size()-1:"+(__fields.size()-1));
if(i < __fields.size()-1){
	sb.append(",");
}
i++;
*/


// TODO NOTE: we won't need to compare if the data is in the table. we won't need to join either.
// aux fields: 
/*
 * 		sb.append("AUX_CREATED_TS TIMESTAMP, ");
		sb.append("AUX_MODIFIED_TS TIMESTAMP, ");
		sb.append("AUX_DELETED_TS TIMESTAMP, ");

 */

//  version
//  x rejected_ts
//  x rejected_by
//  x created: date
//  x  create by  : (first owner)
//  x last mod date:
//  x  last mod by:
//  x delete date:                       isDeleted
//  x  delete by:
//  x  publish read:	                    visible to EXPORT,READ,LOOKUP,WRITE,OWN,APPROVE (always to SUPER/OWN)
//  x  publish write:                     writable to WRITE,OWN						    (always to SUPER/OWN)
//  x  approve/lock date:                 isLocked
//  x  approve/locked by:
//  x  mark arhive:           Y/N
//   current owner:         user
//   current approver:      user
//   inUseBy                (concurrency lock)  isStale (could be stale)   isCommitted (not open/saved)
//   inUseStarted           date                allows expirations if system down and unable to reopen.
//      The concurrency lock means the read is valid.
//   
/*
 *  Rules:
 *  1. The super can access everything.
 *  2. If the owner is no longer in a role, 
 *  		it's good to transfer ownerships to other users in that role
 *  3. If the role no longer has the owner privilege, 
 *  		it's good to create a new role with the privilege and transfer ownersthips to a user in that role.
 *  4. If a user is no longer active, it's ownership should be transferred.
 *  5. If the approver is no longer in a role, 
 *  		any other approver can take over (transfer to self).
 *  
 *  when an owner loses privilege by deactivation, owner role change or role priv change, the approver becomes the new owner
 *  when an approver loses privilege by deactivation, approver role change or role priv change, the super becomes the new owner.
 *  when transferring
 *  when 
 *  
 *  Be able to show 
 *  	1. deserted ownerships (where the owner can't access because: 
 *  		a) not active, 
 *  		b) not in role 
 *  		c) role no longer has privilege
 *  	2. deserted approverships (where the approver can't access because:
 *  		a) not active
 *  		b) not in role
 *  		c) role no longer has approvership
 *  
 *  No "shared" role.  Anyone in a role who is read write or just read is essentially shared with.
 *    An owner might restrict publication.
 *  
 */		




/*
	sb.append("TXFR_USER_ID INTEGER, ");
	sb.append("SIGNATURE VARCHAR(500), ");
 * 
 * 
		StringBuffer sb = new StringBuffer();
	sb.append("CREATE TABLE "+Model.AUX_MODEL+" ("+SqlTranslator.AUTO_PK+", ");
	sb.append("MANAGER_ID INTEGER, ");
	sb.append("MODEL_ID INTEGER, ");
	sb.append("CHANGE_ID INTEGER, ");
	sb.append("EVENT_ID INTEGER, ");
	sb.append("EVENT_STAMP TIMESTAMP, ");
	sb.append("USER_ID INTEGER, ");
	sb.append("TXFR_USER_ID INTEGER, ");
	sb.append("CLIENT VARCHAR(200), ");
	sb.append("ROLE_ID INTEGER, ");
	sb.append("SIGNATURE VARCHAR(500), ");
	//sb.append("CHANGES VARCHAR(8000), ");
	sb.append("COMMENTS VARCHAR(500) ");
	sb.append(")");		
*/
/*
sb.append(model.getManager().getName());
sb.append(" (");
sb.append(" OWNER_ID, STATE, ");
Map<Field,Value> fieldValues = model.getFieldValues();
int i = 0;
for(Field __field:fieldValues.keySet()){
	if(!__field.isIdentity()){
		sb.append(__field.getName());
		//System.out.println("fieldValues.size():"+fieldValues.size());
		if(i<fieldValues.size()-1 ){
			sb.append(",");
		}
	}
	i++;
}
sb.append(" ) VALUES ( ");
sb.append(ownerId+", "+State.SAVED.ordinal());
int j = 0;
for(Field __field:fieldValues.keySet()){
	if(!__field.isIdentity()){
		Value _v = fieldValues.get(__field);

		sb.append(_v.toSql());
		if(j<fieldValues.size()-1 && fieldValues.size()>1){
			sb.append(",");
		}
	}
	j++;
}		
*/
//sb.append(" ) ");
//return sb.toString();